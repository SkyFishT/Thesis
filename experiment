import data,edges,points,points_in_scope,sort_edges,delta_spanner,linprog,os,time,product_probability_matrix
import draw_plot_by_points,product_cars,map_position_by_matrix,draw_plot

def produc_matrix(cross_road,split,global_scope=False):
    global cur_time
    row_cars_file = open(os.path.join(os.getcwd(), 'row_cars.txt'), 'w')
    epsilon_set = [0.69, 1.38, 1.79, 2.07]
    delta = 1.5
    data.productdata(cross_roads)  # product cross road
    edges.productedges(split)  # split roads by segment road
    points.productpoints()  # product points according to segment road
    times=[]
    for epsilon in epsilon_set:
        cur_time = time.time()
        product_probability_matrix.product_matrix(epsilon,delta,radius,True)
        times.append(time.time()-cur_time)

if __name__ == "__main__":
    global cur_time
    epsilon_set = [0.69,1.38,1.79,2.07]
    delta = 1.5
    radius =1000
    cross_roads = 3
    height = width = (cross_roads - 1) * 10
    split = 3.4
    height = width = (cross_roads - 1) * 10
    product_cars.product_cars_by_random(500, width, height, 10)
    cars = eval(open(os.path.join(os.getcwd(), 'row_cars.txt'), 'r').read())
    maping_cars=[]
    for epsilon in epsilon_set:
        cur_time = time.time()
        product_probability_matrix.product_matrix(epsilon,delta,radius,True)
        cur_time = time.time() - cur_time
        print "from main time:" + str(cur_time)
        traverse_cars = map_position_by_matrix.map_position(cars,epsilon)
        maping_cars.append(traverse_cars)
    positions=((cross_roads-1)*10/split+1)*cross_roads*2-cross_roads*cross_roads
    level=len(cars)/float(positions)
    print 'the number of cars:'+str(len(cars))+',the number of positions is:'+str(positions)
    draw_plot_by_points.draw_plot(cars,maping_cars,level)